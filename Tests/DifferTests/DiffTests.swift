import XCTest
@testable import Differ

class DiffTests: XCTestCase {

    let expectations = [
        ("kitten", "sitting", "D(0)I(0)D(4)I(4)I(6)"),
        ("🐩itt🍨ng", "kitten", "D(0)I(0)D(4)I(4)D(6)"),
        ("1234", "ABCD", "D(0)D(1)D(2)D(3)I(0)I(1)I(2)I(3)"),
        ("1234", "", "D(0)D(1)D(2)D(3)"),
        ("", "1234", "I(0)I(1)I(2)I(3)"),
        ("Hi", "Oh Hi", "I(0)I(1)I(2)"),
        ("Hi", "Hi O", "I(2)I(3)"),
        ("Oh Hi", "Hi", "D(0)D(1)D(2)"),
        ("Hi O", "Hi", "D(2)D(3)"),
        ("Wojtek", "Wojciech", "D(3)I(3)I(4)D(5)I(6)I(7)"),
        ("1234", "1234", ""),
        ("", "", ""),
        ("Oh Hi", "Hi Oh", "D(0)D(1)D(2)I(2)I(3)I(4)"),
        ("1362", "31526", "D(0)D(2)I(1)I(2)I(4)")
    ]

    let extendedExpectations = [
        ("sitting", "kitten", "D(0)I(0)D(4)I(4)D(6)"),
        ("🐩itt🍨ng", "kitten", "D(0)I(0)D(4)I(4)D(6)"),
        ("1234", "ABCD", "D(0)D(1)D(2)D(3)I(0)I(1)I(2)I(3)"),
        ("1234", "", "D(0)D(1)D(2)D(3)"),
        ("", "1234", "I(0)I(1)I(2)I(3)"),
        ("Hi", "Oh Hi", "I(0)I(1)I(2)"),
        ("Hi", "Hi O", "I(2)I(3)"),
        ("Oh Hi", "Hi", "D(0)D(1)D(2)"),
        ("Hi O", "Hi", "D(2)D(3)"),
        ("Wojtek", "Wojciech", "D(3)I(3)I(4)D(5)I(6)I(7)"),
        ("1234", "1234", ""),
        ("", "", ""),
        ("gitten", "sitting", "M(0,6)I(0)D(4)I(4)"),
        ("Oh Hi", "Hi Oh", "M(0,3)M(1,4)M(2,2)"),
        ("Hi Oh", "Oh Hi", "M(0,3)M(1,4)M(2,2)"),
        ("12345", "12435", "M(2,3)"),
        ("1362", "31526", "M(0,1)M(2,4)I(2)")
    ]

    func testDiffOutputs() {
        for expectation in expectations {
            XCTAssertEqual(
                _test(from: expectation.0, to: expectation.1),
                expectation.2)
        }
    }

    func testExtendedDiffOutputs() {
        for expectation in extendedExpectations {
            XCTAssertEqual(
                _testExtended(from: expectation.0, to: expectation.1),
                expectation.2)
        }
    }

    func testDiffTracesForDeletion() {
        let traces = "test".diffTraces(to: "")

        XCTAssertEqual(4, traces.count)
        XCTAssertEqual(traces[0], Trace(from: Point(x: 0, y: 0), to: Point(x: 1, y: 0), D: 0))
        XCTAssertEqual(traces[1], Trace(from: Point(x: 1, y: 0), to: Point(x: 2, y: 0), D: 0))
        XCTAssertEqual(traces[2], Trace(from: Point(x: 2, y: 0), to: Point(x: 3, y: 0), D: 0))
        XCTAssertEqual(traces[3], Trace(from: Point(x: 3, y: 0), to: Point(x: 4, y: 0), D: 0))
    }

    func testDiffTracesForInsertion() {
        let traces = "".diffTraces(to: "test")

        XCTAssertEqual(4, traces.count)
        XCTAssertEqual(traces[0], Trace(from: Point(x: 0, y: 0), to: Point(x: 0, y: 1), D: 0))
        XCTAssertEqual(traces[1], Trace(from: Point(x: 0, y: 1), to: Point(x: 0, y: 2), D: 0))
        XCTAssertEqual(traces[2], Trace(from: Point(x: 0, y: 2), to: Point(x: 0, y: 3), D: 0))
        XCTAssertEqual(traces[3], Trace(from: Point(x: 0, y: 3), to: Point(x: 0, y: 4), D: 0))
    }

    // The tests below check efficiency of the algorithm

    func testDuplicateTraces() {
        for expectation in expectations {
            XCTAssertFalse(duplicateTraces(from: expectation.0, to: expectation.1))
        }
    }

    func testTracesOutOfBounds() {
        for expectation in expectations {
            XCTAssertEqual(tracesOutOfBounds(from: expectation.0, to: expectation.1), [], "traces out of bounds for \(expectation.0) -> \(expectation.1)")
        }
    }

    func testSingleElementArray() {
        let changes = "a".diff("a")
        XCTAssertEqual(changes.elements.count, 0)
    }

    func duplicateTraces(from: String, to: String) -> Bool {
        let traces = from.diffTraces(to: to)
        let tracesSet = Set(traces)
        return !(traces.count == tracesSet.count)
    }

    func tracesOutOfBounds(from: String, to: String) -> [Trace] {
        let ac = from
        let bc = to
        return ac.diffTraces(to: bc)
            .filter { $0.to.y > bc.count || $0.to.x > ac.count }
    }

    func _test(
        from: String,
        to: String) -> String {
        return from
            .diff(to)
            .reduce("") { $0 + $1.debugDescription }
    }

    func _testExtended(
        from: String,
        to: String) -> String {
        return from
            .extendedDiff(to)
            .reduce("") { $0 + $1.debugDescription }
    }


    func testRandomReorder() {
        (0..<1000).forEach { _ in
            let count = Int.random(in: 5..<10)
            let originalOrder = (0..<count).map { $0 }
            let updatedOrder = originalOrder.shuffled()

            print("originalOrder \(originalOrder), updatedOrder \(updatedOrder)")

            let changes = extendedPatch(from: originalOrder, to: updatedOrder)
            let result = originalOrder.apply(changes)

            XCTAssertEqual(updatedOrder, result)
        }
    }

    // Specific cases generated by testRandomReorder that crash or produced incorrect results previously.

    func testRandomReorder1() {
        let originalOrder = [0, 1, 2, 3, 4]
        let updatedOrder = [4, 3, 2, 0, 1]

        let changes = extendedPatch(from: originalOrder, to: updatedOrder)
        let result = originalOrder.apply(changes)

        XCTAssertEqual(updatedOrder, result)
    }

}
